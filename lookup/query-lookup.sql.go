// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query-lookup.sql

package lookup

import (
	"context"
)

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (
    group_id,
    group_name
) VALUES (?, ?) RETURNING group_id, group_name
`

type CreateGroupParams struct {
	GroupID   string `json:"group_id"`
	GroupName string `json:"group_name"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.queryRow(ctx, q.createGroupStmt, createGroup, arg.GroupID, arg.GroupName)
	var i Group
	err := row.Scan(&i.GroupID, &i.GroupName)
	return i, err
}

const createServer = `-- name: CreateServer :one
INSERT INTO servers (
    server_id,
    output_channel,
    group_id,
    permission_level
) VALUES (?, ?, ?, ?) RETURNING server_id, output_channel, group_id, permission_level
`

type CreateServerParams struct {
	ServerID        int64  `json:"server_id"`
	OutputChannel   int64  `json:"output_channel"`
	GroupID         string `json:"group_id"`
	PermissionLevel int64  `json:"permission_level"`
}

func (q *Queries) CreateServer(ctx context.Context, arg CreateServerParams) (Server, error) {
	row := q.queryRow(ctx, q.createServerStmt, createServer,
		arg.ServerID,
		arg.OutputChannel,
		arg.GroupID,
		arg.PermissionLevel,
	)
	var i Server
	err := row.Scan(
		&i.ServerID,
		&i.OutputChannel,
		&i.GroupID,
		&i.PermissionLevel,
	)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM groups
WHERE group_id = ?
`

func (q *Queries) DeleteGroup(ctx context.Context, groupID string) error {
	_, err := q.exec(ctx, q.deleteGroupStmt, deleteGroup, groupID)
	return err
}

const deleteServer = `-- name: DeleteServer :exec
DELETE FROM servers
WHERE server_id = ? AND group_id = ?
`

type DeleteServerParams struct {
	ServerID int64  `json:"server_id"`
	GroupID  string `json:"group_id"`
}

func (q *Queries) DeleteServer(ctx context.Context, arg DeleteServerParams) error {
	_, err := q.exec(ctx, q.deleteServerStmt, deleteServer, arg.ServerID, arg.GroupID)
	return err
}

const getGroup = `-- name: GetGroup :one
SELECT group_id, group_name FROM groups
WHERE group_id = ? LIMIT 1
`

func (q *Queries) GetGroup(ctx context.Context, groupID string) (Group, error) {
	row := q.queryRow(ctx, q.getGroupStmt, getGroup, groupID)
	var i Group
	err := row.Scan(&i.GroupID, &i.GroupName)
	return i, err
}

const getServerCount = `-- name: GetServerCount :one
SELECT COUNT(*) FROM servers
WHERE group_id = ?
`

func (q *Queries) GetServerCount(ctx context.Context, groupID string) (int64, error) {
	row := q.queryRow(ctx, q.getServerCountStmt, getServerCount, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getServerGroup = `-- name: GetServerGroup :one
SELECT g.group_id, g.group_name
FROM groups g
JOIN servers s ON s.group_id = g.group_id
WHERE s.server_id = ?
`

func (q *Queries) GetServerGroup(ctx context.Context, serverID int64) (Group, error) {
	row := q.queryRow(ctx, q.getServerGroupStmt, getServerGroup, serverID)
	var i Group
	err := row.Scan(&i.GroupID, &i.GroupName)
	return i, err
}

const listGroups = `-- name: ListGroups :many
SELECT group_id, group_name FROM groups
ORDER BY group_id
`

func (q *Queries) ListGroups(ctx context.Context) ([]Group, error) {
	rows, err := q.query(ctx, q.listGroupsStmt, listGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.GroupID, &i.GroupName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroup = `-- name: UpdateGroup :exec
UPDATE groups
SET group_name = ?
WHERE group_id = ?
`

type UpdateGroupParams struct {
	GroupName string `json:"group_name"`
	GroupID   string `json:"group_id"`
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) error {
	_, err := q.exec(ctx, q.updateGroupStmt, updateGroup, arg.GroupName, arg.GroupID)
	return err
}
